---
import styles from "./HeroVisual.module.css";

const process = [
  {
    title: "Figma",
    image: "/images/icons/figma-logo.svg"
  },
  {
    title: "Cursor",
    image: "/images/icons/cursor-logo.svg"
  },
  {
    title: "Docker",
    image: "/images/icons/docker-logo.svg"
  },
  {
    title: "Supabase",
    image: "/images/icons/supabase.svg"
  },
  {
    title: "AWS",
    image: "/images/icons/aws-logo.svg"
  },
  {
    title: "Check",
    image: "/images/icons/check-logo.svg"
  },
]

const rustCode = `pub fn kury_sol_exec(id: Sig) -> Result<Ok, Err> {
  let sol = solana::connect(id).ok()?;

  if sol.is_verified() {
    let receipt = KuryVault {
      status: "SUCCESS",
      ledger: "SOL_MAIN",
      method: "PROTOCOL",
      author: "KURY_DEV",
      amount: 1000.000,
      secure: true,
    };
    println!("✅ Kurybank: Sol-Sync Complete");
    return Ok(receipt);
  }
  Err(Error::Incomplete)
}`;
---

<div class={styles.rightSection}>
  <div class={styles.imageContainer}>
    <img src="/images/hero-image.svg" alt="Hero Image" />
  </div>
  
  <div class={styles.codeContainer}>
    <pre class={styles.code}>
      <code class="language-rust" id="code-display"></code>
    </pre>
  </div>
  
  <div class={styles.processContainer}>
    {process.map((item, index) => (
      <div class={styles.processItem} title={item.title}>
        <div class={styles.processIcon}>
          <img src={item.image} alt={item.title} />
        </div>
        {index < process.length - 1 && (
          <img src="/images/icons/conector.svg" alt="" class={styles.processArrow} />
        )}
      </div>
    ))}
  </div>
</div>

<script>
  (function() {
    const prismCore = document.createElement('script');
    prismCore.src = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js';
    prismCore.onload = function() {
      const prismRust = document.createElement('script');
      prismRust.src = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js';
      document.head.appendChild(prismRust);
    };
    document.head.appendChild(prismCore);
  })();
</script>

<script is:inline define:vars={{ rustCode }}>
  (function() {
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function waitForPrism(maxAttempts = 100) {
      let attempts = 0;
      while (!window.Prism && attempts < maxAttempts) {
        await sleep(100);
        attempts++;
      }
      return !!window.Prism;
    }

    async function waitForRustLanguage(maxAttempts = 100) {
      let attempts = 0;
      while ((!window.Prism?.languages?.rust) && attempts < maxAttempts) {
        await sleep(100);
        attempts++;
      }
      return !!window.Prism?.languages?.rust;
    }

    async function typeHighlightedCode(targetElement, code) {
      if (!(await waitForPrism())) {
        console.error('Prism Core no se cargó');
        targetElement.textContent = code;
        return;
      }

      if (!(await waitForRustLanguage())) {
        console.error('Prism Rust no se cargó');
        targetElement.textContent = code;
        return;
      }

      const tempPre = document.createElement('pre');
      tempPre.style.cssText = 'position: absolute; left: -9999px; visibility: hidden;';
      
      const realPre = targetElement.closest('pre');
      if (realPre) {
        const computedStyle = window.getComputedStyle(realPre);
        tempPre.style.fontFamily = computedStyle.fontFamily;
        tempPre.style.fontSize = computedStyle.fontSize;
        tempPre.style.lineHeight = computedStyle.lineHeight;
        tempPre.style.padding = computedStyle.padding;
        tempPre.style.margin = computedStyle.margin;
        tempPre.style.whiteSpace = computedStyle.whiteSpace;
      }
      
      const tempCode = document.createElement('code');
      tempCode.className = 'language-rust';
      tempCode.textContent = code;
      tempPre.appendChild(tempCode);
      document.body.appendChild(tempPre);
      
      window.Prism.highlightElement(tempCode);
      
      void tempPre.offsetHeight;
      const finalHeight = tempPre.offsetHeight;
      
      const codePre = targetElement.closest('pre');
      const codeContainer = codePre?.parentElement;
      
      if (codePre && codeContainer) {
        codePre.style.cssText = `height: ${finalHeight}px; min-height: ${finalHeight}px; max-height: ${finalHeight}px; overflow: hidden;`;
        targetElement.style.cssText = `max-height: ${finalHeight}px; overflow: hidden; display: block;`;
        codeContainer.style.cssText = `height: ${finalHeight}px; min-height: ${finalHeight}px;`;
        
        void codePre.offsetHeight;
        void codeContainer.offsetHeight;
        void targetElement.offsetHeight;
      }
      
      await new Promise(resolve => requestAnimationFrame(resolve));
      
      const nodes = Array.from(tempCode.childNodes);
      targetElement.innerHTML = '';
      
      for (const node of nodes) {
        targetElement.appendChild(node.cloneNode(true));
        const nodeText = node.textContent || '';
        const delay = /^\s+$/.test(nodeText) ? 8 : 30;
        await sleep(delay);
      }
      
      tempPre.remove();
    }

    async function init() {
      const codeElement = document.getElementById('code-display');
      if (codeElement) {
        await sleep(300);
        await typeHighlightedCode(codeElement, rustCode);
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  })();
</script>
